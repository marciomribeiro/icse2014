%!TEX root = ../main.tex

\section{Introduction}

Developers often introduce errors into software systems during maintenance when they fail to recognize module and feature dependencies~\cite{herbsleb-feature-dependencies-icse11}. This problem is particularly critical for configurable systems, in which features can be enabled and disabled at compile time or run time, and market and technical needs constrain how features can be combined. In this context, features often crosscut each other~\cite{liebig-40spls-icse10} and share program elements like variables and methods~\cite{ribeiro-feature-dependencies-gpce11}, without proper modularity support from a notion of interface between features. In such context, developers can easily miss cross-feature dependencies, such as  a feature assigning a value to a variable read by another feature. As there is no mutual agreement~\cite{mary-shaw-global-variable-harmful-73} between separate feature developers, changing one feature might be the correct action for maintaining the feature, but might bring undesirable consequences to the behavior of the other feature. Similar issues could also appear when developers assume invalid dependencies, as would be the case if the just discussed features were mutually exclusive. In a prior study collecting metrics of 43 large-scale open-source implementations based on preprocessor mechanisms, we found that cross-feature dependencies are frequent in practice~\cite{ribeiro-feature-dependencies-gpce11}.

To reduce this feature dependency problem, we propose a technique called \emph{emergent interfaces} that establishes, on demand and according to a given code change task, interfaces to feature code (introduced previously in a vision paper~\cite{ribeiro-emergent-onward10}). An emergent interface is a list of contracts stating the code lines data dependent on the code lines we are supposed to change during the task. We call our technique emergent because, instead of writing interfaces manually, developers can request interfaces on demand; that is, interfaces emerge to support a specific code change task.
This way, developers become aware of feature dependencies, and may have better chance of not introducing errors~\cite{yin-fixes-become-bugs-fse11}. Our interfaces may also help to reduce code change effort. In fact, instead of searching for dependencies throughout the code, and reasoning about requirements-level feature constraints, developers can rely on proper tool support that computes interfaces.

We implemented emergent interfaces in a tool \emph{Emergo}, available as Eclipse plugin for Java. Emergo performs feature-sensitive data-flow analysis to compute interfaces on demand, both at \textit{intraprocedural} and at \textit{interprocedural} level.

A key novelty in this paper is an empirical evaluation of emergent interfaces as provided by Emergo. We conducted and replicated a \emph{controlled experiment} on feature-related code change tasks in software product lines. The product lines are implemented with a preprocessor-like variability mechanisms, which are widely used to implement compile-time variability in industrial practice, despite their lack of modularity mechanisms.
%To evaluate the potential of emergent interfaces to reduce errors and development effort, and better understand to what extent they support feature modularity, we conducted and replicated a \emph{controlled experiment} on maintenance tasks in software product lines.
%Our study focuses on feature-related maintenance tasks in  preprocessor-based product-line implementations, which are widely used to implement compile-time variability in industrial practice despite their lack of modularity mechanisms. Also, to aid comprehensibility, we consider tasks performed with support for virtual separation of concerns (VSoC)~\cite{christian-cide-icse08}, which allows developers to hide code fragments not related to features associated to a given task. This way we allow developers to focus on a feature and its (emergent) interface without the distraction brought by other features.
In particular, we evaluate emergent interfaces by answering two research questions: \textit{Do emergent interfaces reduce effort during code change tasks involving feature code dependencies in preprocessor-based systems? Do emergent interfaces reduce the number of errors during code change tasks involving feature code dependencies in preprocessor-based systems?} We consider tasks that involve both \textit{intraprocedural} and \textit{interprocedural} feature dependencies from two product lines. We first conduct the experiment in one institution, recruiting graduate students as subjects, and then replicate it in another institution with undergraduate students. %In both cases, around half of the students have professional experience.

Our experiment reveals that, in our setting, emergent interfaces significantly reduce maintenance effort for tasks involving \textit{interprocedural} dependencies, which cross method boundaries. Both experiment rounds reveal that developers were, on average, 3 times faster completing our code change tasks when using emergent interfaces. As for tasks involving only \textit{intraprocedural} dependencies, we confirm statistical significance in only one round, in which we on average observe a 1.6 fold improvement in favor of emergent interfaces. In line with recent research~\cite{yin-fixes-become-bugs-fse11}, in both rounds we observe that presenting feature dependencies help developers to detect and avoid errors, regardless of the kinds of dependencies.

In summary, we make the following contributions: 
\begin{itemize}

	\item A comprehensive introduction to emergent interfaces and a complete implementation of the concept in Emergo, supporting both \textit{intraprocedural} analysis but also on the much more powerful \textit{interprocedural} analysis.
	
	\item An empirical evaluation assessing the potential of emergent interfaces. We evaluate effort and error reduction when using emergent interfaces in a controlled (and replicated) experiment with in total 24 participants in two product lines and demonstrate significant potential.
\end{itemize}

The idea of emergent interfaces was first introduced in an Onward! paper~\cite{ribeiro-emergent-onward10}, with an early prototypical implementation approximating \textit{intraprocedural} data-flow analysis. Subsequently, we statically analyzed the potential impact of emergent interfaces in 43 open source projects~\cite{ribeiro-feature-dependencies-gpce11} and investigated feature-sensitive data-flow analyses~\cite{brabrand-dfa4spl-aosd12}. This paper brings together these results and reports on a significantly revised and extended version of Emergo that supports precise, feature-sensitive, and \textit{interprocedural} data-flow analysis and additionally complements them with a novel significant empirical evaluation.

%(1) We revise the emergent feature modularization concept from the previous vision paper~\cite{ribeiro-emergent-onward10} and extend and evaluate tool support from \textit{intraprocedural} analysis to the much more powerful \textit{interprocedural} analysis; (2) We evaluate effort and error reduction when using emergent interfaces in a controlled (and replicated) experiment with in total 24 participants in two product lines and demonstrate significant potential. We complement our previous evaluation results~\cite{ribeiro-feature-dependencies-gpce11}, which focused only on \textit{intraprocedural} dependencies, measured only effort, and used proxy metrics without proper tool support for emergent interfaces.

%\reviewer{You really need to make the difference compared to the older  papers clearer in the introduction. You talk about intra versus inter procedural, and about previous evaluation results, but when looking at the previous papers, the best way to describe the difference is that this paper presents a comprehensive evaluation. That's what it does and does quite well.}

%We structure the remainder of the paper as follows. Section~\ref{sec:motivating} presents motivating examples for the problem caused by feature dependencies. To reduce this problem, we show emergent interfaces in Section~\ref{sec:emergent}. Then, we present the experimental design of our evaluation in Section~\ref{sec:experimental-design} and the results in Section~\ref{sec:results}. Finally, we present related work and concluding remarks.